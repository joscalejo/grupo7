<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ford-Fulkerson: Grupo 7 (con conectividad m√≠nima)</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        :root { --primary: #2c3e50; --secondary: #3498db; --success: #27ae60; --danger: #e74c3c; --warning: #f39c12; --light: #ecf0f1; }
        body { font-family: 'Segoe UI', sans-serif; background: #f5f6fa; margin: 0; padding: 20px; color: var(--primary); display: flex; flex-direction: column; height: 95vh; }
        h1 { text-align: center; margin-bottom: 10px; }
        .panel { background: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); margin-bottom: 15px; }
        .hidden { display: none; }
        .control-group { margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        label { font-weight: 600; margin-right: 5px; }
        input[type="number"], select { padding: 10px; border: 2px solid var(--light); border-radius: 4px; width: 100px; }
        textarea { width: 100%; height: 80px; padding: 8px; border: 2px solid var(--light); border-radius: 4px; font-family: monospace; resize: vertical; }
        button { padding: 10px 18px; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; color: white; transition: 0.2s; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-blue { background: var(--secondary); } .btn-blue:hover { background: #2980b9; }
        .btn-green { background: var(--success); } .btn-green:hover { background: #219a52; }
        .btn-orange { background: var(--warning); } .btn-orange:hover { background: #d68910; }
        .btn-gray { background: #95a5a6; } .btn-gray:hover { background: #7f8c8d; }
        #main-container { display: flex; flex: 1; gap: 20px; min-height: 400px; }
        #network-view { flex: 3; border-radius: 8px; border: 2px solid var(--light); background: white; }
        #log-view { flex: 1; display: flex; flex-direction: column; background: white; border-radius: 8px; border: 2px solid var(--light); padding: 15px; overflow-y: auto; }
        .log-item { padding: 8px 10px; margin-bottom: 8px; border-left: 4px solid var(--secondary); background: #f8f9fa; font-size: 0.9em; }
        .log-success { border-left-color: var(--success); background: #eafaf1; }
        .log-error { border-left-color: var(--danger); background: #fdedec; }
        .log-info { border-left-color: var(--warning); background: #fef9e7; }
        .legend { margin-top: auto; padding-top: 15px; border-top: 1px solid var(--light); font-size: 0.85em; }
        .badge { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; vertical-align: middle; }
    </style>
</head>
<body>

    <h1>Problema del Flujo Maximo - Grupo 7</h1>

    <div id="setup-panel" class="panel">
        <div class="control-group">
            <span><strong>Elija el modo de generacion del grafo:</strong></span>
            <button class="btn-blue" onclick="toggleMode('random')">üé≤ Aleatorio</button>
            <button class="btn-blue" onclick="toggleMode('manual')">‚úçÔ∏è Manual</button>
        </div>
        <div id="mode-random" class="hidden">
            <div class="control-group">
                <label>Introduzca la cantidad de nodos del grafo (de 8 a 16 max):</label>
                <input type="number" id="n-random" min="8" max="16" value="10">
                <button class="btn-green" onclick="generarAleatorio()">Generar grafo</button>
            </div>
            <div style="font-size:0.9em;color:#555;">Nota: la generaci√≥n aleatoria garantiza que cada nodo intermedio tenga al menos una arista entrante y una saliente; la fuente es 0 y el sumidero es n-1.</div>
        </div>
        <div id="mode-manual" class="hidden">
            <div class="control-group"><label>Introduzca la cantidad de nodos del grafo (de 8 a 16 max):</label><input type="number" id="n-manual" min="8" max="16" value="8"></div>
            <label><b>Formato de entrada:</b> Vertice Inicial -> Vertice Final - Peso</label>
            <label><b>Ejemplo:</b> 0 1 5 donde 0 y 1 son los vertices y 5 el peso de la arista que los conecta.</label>
            <textarea id="manual-edges" placeholder="0 1 10&#10;0 2 8..."></textarea>
            <button class="btn-green" style="margin-top:10px;" onclick="generarManual()">Generar grafo</button>
            <div style="font-size:0.9em;color:#555;margin-top:6px;">La entrada manual ser√° validada: no se permiten nodos aislados ni nodos intermedios sin entrada o sin salida; adem√°s debe existir al menos un camino 0 ‚Üí n-1.</div>
        </div>
    </div>

    <div id="execution-panel" class="panel hidden">
        <div class="control-group" style="background: #eafaf1; padding: 10px; border-radius: 6px;">
            <label>Fuente (S):</label><select id="sel-fuente" disabled></select>
            <label>Sumidero (T):</label><select id="sel-sumidero" disabled></select>
        </div>
        <div id="algo-controls" class="control-group hidden">
            <span><strong>Escoja una opcion:</strong></span>
            <button id="btn-step" class="btn-orange" onclick="pasoAlgoritmo()">üë£ Paso a paso</button>
            <button id="btn-run" class="btn-green" onclick="ejecutarTodo()">üöÄ Ir al resultado</button>
            <button id="btn-reset" class="btn-gray" onclick="reiniciarFlujos()">üîÑ Reiniciar grafo</button>
            <label style="font-size: 0.9em; margin-left: 10px;">
                <input type="checkbox" id="chk-random-dfs">Aleatorizar b√∫squeda (ver alternativas) &nbsp; - &nbsp;
                Presionar CTRL + Rueda del mouse arriba/abajo para zoom &nbsp; - &nbsp;
                Pulsar "reiniciar grafo" antes de generar uno nuevo
            </label>
        </div>
    </div>

    <div id="main-container">
        <div id="network-view"></div>
        <div id="log-view">
            <h3 style="margin-top:0;">Bit√°cora</h3>
            <div id="log-entries"></div>
            <div class="legend">
                <strong>Leyenda:</strong>
                <div><span class="badge" style="background:#2ecc71"></span>Fuente ( S )</div>
                <div><span class="badge" style="background:#e74c3c"></span>Sumidero ( T )</div>
                <div><span class="badge" style="background:#f1c40f"></span>Nodos del Lado S de la cortadura</div>
                <div style="margin-top:5px; display: flex; align-items: center;">
                    <div style="width: 30px; height: 3px; background: #f39c12; margin-right: 8px;"></div>
                    Flujo actual
                </div>
                <div style="margin-top:5px; display: flex; align-items: center;">
                    <div style="width: 30px; height: 3px; background: red; margin-right: 8px;"></div>
                    L√≠nea Saturada.
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Variables Globales ---
        let network;
        let nodesDS = new vis.DataSet(), edgesDS = new vis.DataSet();
        let grafo = {};
        let flujos = {};
        let N = 0;
        let fuente = -1, sumidero = -1;
        let pasos = 0, terminado = false;
        let aristasCorte = [];

        // --- UI helpers ---
        function log(msg, type='') {
            const container = document.getElementById('log-entries');
            const node = document.createElement('div');
            node.className = `log-item ${type ? 'log-' + type : ''}`;
            node.innerHTML = msg;
            container.insertAdjacentElement('afterbegin', node);
        }
        function limpiarLog(){ document.getElementById('log-entries').innerHTML = ''; }

        function toggleMode(mode) {
            document.getElementById('mode-random').classList.toggle('hidden', mode !== 'random');
            document.getElementById('mode-manual').classList.toggle('hidden', mode !== 'manual');
            document.getElementById('execution-panel').classList.add('hidden');
            limpiarLog();
            if (network) { network.destroy(); network = null; }
            document.getElementById('network-view').innerHTML = '';
            grafo = {}; flujos = {}; N = 0; fuente = -1; sumidero = -1; pasos = 0; terminado = false; aristasCorte = [];
            nodesDS.clear(); edgesDS.clear();
            document.getElementById('algo-controls').classList.add('hidden');
        }

        // --- Generacion aleatoria con niveles y bipartita completa entre niveles adyacentes ---
        function generarAleatorio() {
            N = parseInt(document.getElementById('n-random').value);
            if (isNaN(N) || N < 8 || N > 16) { log("Error: El numero de nodos debe estar entre [8, 16]", 'error'); return; }

            grafo = Array.from({length: N}, () => ({}));

            // elegimos cantidad de niveles intermedios para distribuir nodos (entre 1 y 4)
            const intermedios = Math.min(4, Math.max(1, Math.floor((N - 2) / 2)));
            const totalLevels = intermedios + 2; // incluyendo fuente y sumidero
            const levels = Array.from({length: totalLevels}, () => []);

            // asignar nodos a niveles:
            levels[0].push(0);
            levels[totalLevels - 1].push(N - 1);
            // repartir los N-2 nodos intermedios en los niveles 1..totalLevels-2 (bloques consecutivos para mantener proximidad)
            const interN = N - 2;
            let base = Math.floor(interN / intermedios);
            let rem = interN % intermedios;
            let node = 1;
            for (let li = 1; li <= intermedios; li++) {
                let count = base + (rem > 0 ? 1 : 0);
                if (rem > 0) rem--;
                for (let k = 0; k < count; k++) {
                    if (node <= N - 2) { levels[li].push(node); node++; }
                }
            }
            // safety: if quedaron sin asignar (raro), asignarlos secuencialmente
            while (node <= N - 2) { levels[intermedios].push(node); node++; }

            // Conectar completamente cada nivel con el siguiente (garantiza in>=1 y out>=1 para intermedios)
            for (let i = 0; i < totalLevels - 1; i++) {
                const A = levels[i], B = levels[i + 1];
                A.forEach(u => {
                    B.forEach(v => {
                        if (!grafo[u][v]) grafo[u][v] = Math.floor(Math.random() * 20) + 5; // 5-24
                    });
                });
            }

            // A√±adir algunas aristas extra "saltando" niveles para densidad (aleatorio)
            for (let i = 0; i < totalLevels; i++) {
                for (const u of levels[i]) {
                    // intentos extras seg√∫n tama√±o
                    let extras = Math.floor(Math.random() * 2); // 0-1 extras
                    for (let e = 0; e < extras; e++) {
                        // elegir un nivel objetivo > i (hasta +2 niveles)
                        const saltoNivel = Math.floor(Math.random() * Math.min(2, totalLevels - 1 - i)) + 1;
                        const nivelObjetivo = i + saltoNivel;
                        if (nivelObjetivo < totalLevels) {
                            const candidatos = levels[nivelObjetivo];
                            if (candidatos.length > 0) {
                                const v = candidatos[Math.floor(Math.random() * candidatos.length)];
                                if (!grafo[u][v]) grafo[u][v] = Math.floor(Math.random() * 20) + 5;
                            }
                        }
                    }
                }
            }

            // Verificacion por si falla algo (por robustez): confirmamos grados m√≠nimos (deber√≠a cumplirse)
            const faltan = [];
            for (let x = 1; x <= N - 2; x++) {
                let inDeg = 0, outDeg = 0;
                for (let u = 0; u < N; u++) if (grafo[u] && grafo[u][x]) inDeg++;
                outDeg = Object.keys(grafo[x] || {}).length;
                if (inDeg < 1 || outDeg < 1) faltan.push({node: x, inDeg, outDeg});
            }
            if (faltan.length > 0) {
                // si por alguna razon hay nodos que no cumplen, intentamos arreglar conectandolos al siguiente y anterior
                faltan.forEach(f => {
                    const u = f.node;
                    if (f.inDeg < 1) {
                        // conectar desde nodo anterior m√°s cercano (u-1) o desde la fuente
                        const from = Math.max(0, u - 1);
                        if (!grafo[from][u]) grafo[from][u] = Math.floor(Math.random() * 20) + 5;
                    }
                    if (f.outDeg < 1) {
                        const to = Math.min(N - 1, u + 1);
                        if (!grafo[u][to]) grafo[u][to] = Math.floor(Math.random() * 20) + 5;
                    }
                });
            }

            prepararVisualizacion();
            log(`Grafo aleatorio de ${N} nodos generado con ${totalLevels} niveles.`, 'success');
        }

        // --- Generacion manual con validacion estricta ---
        function generarManual() {
            N = parseInt(document.getElementById('n-manual').value);
            if (isNaN(N) || N < 8 || N > 16) { log("Error: El numero de nodos debe estar entre [8, 16]", 'error'); return; }
            grafo = Array.from({length: N}, () => ({}));
            try {
                const raw = document.getElementById('manual-edges').value.trim();
                if (raw.length === 0) { log("Error: No se detectaron aristas en la entrada manual.", 'error'); return; }
                raw.split('\n').forEach(linea => {
                    const parts = linea.trim().split(/\s+/);
                    if (parts.length >= 3) {
                        const u = Number(parts[0]), v = Number(parts[1]), c = Number(parts[2]);
                        if (!Number.isNaN(u) && !Number.isNaN(v) && !Number.isNaN(c) && u >= 0 && u < N && v >= 0 && v < N && c > 0) {
                            grafo[u][v] = (grafo[u][v] || 0) + c;
                        }
                    }
                });

                // VALIDACION MANUAL:
                // 1) No hay nodos aislados (grado 0)
                // 2) Para cada nodo intermedio (1..N-2): inDeg >=1 && outDeg >=1
                // 3) Debe existir al menos un camino 0 -> N-1
                let errores = [];

                for (let u = 0; u < N; u++) {
                    let outDeg = Object.keys(grafo[u] || {}).length;
                    let inDeg = 0;
                    for (let i = 0; i < N; i++) if (grafo[i] && grafo[i][u]) inDeg++;
                    if (inDeg + outDeg === 0) errores.push(`Nodo ${u} est√° aislado.`);
                }

                // revisa intermedios
                for (let u = 1; u <= N - 2; u++) {
                    let outDeg = Object.keys(grafo[u] || {}).length;
                    let inDeg = 0;
                    for (let i = 0; i < N; i++) if (grafo[i] && grafo[i][u]) inDeg++;
                    if (inDeg < 1) errores.push(`Nodo ${u} no tiene aristas entrantes.`);
                    if (outDeg < 1) errores.push(`Nodo ${u} no tiene aristas salientes.`);
                }

                // check path 0 -> N-1 (BFS)
                const reach = (start) => {
                    let q = [start], seen = new Set([start]);
                    while (q.length) {
                        let x = q.shift();
                        for (let vStr of Object.keys(grafo[x] || {})) {
                            let v = parseInt(vStr);
                            if (!seen.has(v)) { seen.add(v); q.push(v); }
                        }
                    }
                    return seen;
                };
                const reach0 = reach(0);
                if (!reach0.has(N - 1)) errores.push(`No existe camino dirigido desde la fuente (Nodo 0) hasta el sumidero (Nodo ${N - 1}).`);

                if (errores.length > 0) {
                    log(`<strong>Validaci√≥n fallida:</strong><br>${errores.join('<br>')}`, 'error');
                    return;
                }

                prepararVisualizacion();
                log("Grafo manual construido y validado.", 'success');
            } catch (e) {
                log("Error en formato manual.", 'error');
            }
        }

        // --- Visualizacion ---
        function prepararVisualizacion() {
            nodesDS.clear(); edgesDS.clear();
            for (let i = 0; i < N; i++) nodesDS.add({ id: i, label: `${i}`, color: '#3498db' });
            for (let u = 0; u < N; u++) {
                for (let v in grafo[u]) {
                    edgesDS.add({ id: `${u}-${v}`, from: u, to: parseInt(v), capacity: grafo[u][v], label: `0/${grafo[u][v]}`, arrows:'to', color:'#95a5a6' });
                }
            }
            if (network) network.destroy();
            network = new vis.Network(document.getElementById('network-view'), { nodes: nodesDS, edges: edgesDS }, {
                layout: {
                    hierarchical: {
                        direction: 'LR',
                        sortMethod: 'directed',
                        levelSeparation: 200,
                        nodeSpacing: 300,
                        treeSpacing: 200,
                        blockShifting: true,
                        edgeMinimization: true,
                        parentCentralization: true
                    }
                },
                physics: false,
                edges: { smooth: false, font: { align: 'top', size: 16 } },
                nodes: { font: { color: 'white' }, borderWidth: 2, size: 30 },
                interaction: { dragNodes: true, zoomView: true, dragView: true }
            });

            network.on("afterDrawing", (ctx) => {
                if (aristasCorte.length === 0) return;
                let sumX = 0, sumY = 0, sumDx = 0, sumDy = 0, count = 0;
                aristasCorte.forEach(edgeId => {
                    const edge = edgesDS.get(edgeId);
                    if (!edge) return;
                    const posU = network.getPositions([edge.from])[edge.from];
                    const posV = network.getPositions([edge.to])[edge.to];
                    sumX += (posU.x + posV.x) / 2; sumY += (posU.y + posV.y) / 2;
                    sumDx += (posV.x - posU.x); sumDy += (posV.y - posU.y);
                    count++;
                });
                if (count === 0) return;
                const avgX = sumX / count, avgY = sumY / count, avgDx = sumDx / count, avgDy = sumDy / count;
                let perpDx = -avgDy, perpDy = avgDx;
                const len = Math.sqrt(perpDx*perpDx + perpDy*perpDy);
                if (len > 0) { perpDx /= len; perpDy /= len; }
                ctx.save();
                ctx.strokeStyle = '#F527EE'; ctx.lineWidth = 3; ctx.setLineDash([10,5]); ctx.beginPath();
                ctx.moveTo(avgX - perpDx * 1400, avgY - perpDy * 1400); ctx.lineTo(avgX + perpDx * 1400, avgY + perpDy * 1400); ctx.stroke();
                ctx.restore();
            });

            // Fuente y sumidero fijos y deshabilitados en la UI
            const sSel = document.getElementById('sel-fuente'), tSel = document.getElementById('sel-sumidero');
            sSel.innerHTML = tSel.innerHTML = '';
            for (let i = 0; i < N; i++) { sSel.add(new Option(`Nodo ${i}`, i)); tSel.add(new Option(`Nodo ${i}`, i)); }
            fuente = 0; sumidero = N - 1;
            sSel.value = fuente; tSel.value = sumidero;
            nodesDS.update([{ id: fuente, label: `S (${fuente})`, color: '#2ecc71' }, { id: sumidero, label: `T (${sumidero})`, color: '#e74c3c' }]);

            document.getElementById('execution-panel').classList.remove('hidden');
            document.getElementById('algo-controls').classList.remove('hidden');

            reiniciarFlujos();
            network.fit({ animation: { duration: 600, easingFunction: 'easeInOutQuad' } });
        }

        // --- Reiniciar flujos ---
        function reiniciarFlujos() {
            flujos = {}; pasos = 0; terminado = false; aristasCorte = [];
            for (let u = 0; u < N; u++) flujos[u] = {};
            edgesDS.forEach(e => {
                if (grafo[e.from] && grafo[e.from][e.to]) {
                    edgesDS.update({ id: e.id, label: `0/${e.capacity}`, color: '#95a5a6', width: 1 });
                }
            });
            nodesDS.forEach(n => { if (n.id !== fuente && n.id !== sumidero) nodesDS.update({ id: n.id, color: '#3498db' }); });
            network.redraw();
            limpiarLog();
            log("Listo para ejecutar.", 'info');
        }

        // --- BFS residual ---
        function bfs(s, t, padre, res) {
            let visitados = new Set([s]);
            let q = [s];
            padre[s] = -1;
            while (q.length > 0) {
                let u = q.shift();
                let vecinos = Object.keys(res[u] || {});
                if (document.getElementById('chk-random-dfs').checked) vecinos.sort(() => Math.random() - 0.5);
                for (let vStr of vecinos) {
                    let v = parseInt(vStr);
                    if (!visitados.has(v) && res[u][v] > 0) {
                        q.push(v); visitados.add(v); padre[v] = u;
                        if (v === t) return { encontrado: true, visitados: visitados };
                    }
                }
            }
            return { encontrado: false, visitados: visitados };
        }

        // --- Paso a paso ---
        function pasoAlgoritmo() {
            if (terminado) return;
            let res = Array.from({length: N}, () => ({}));
            edgesDS.forEach(e => {
                let f = flujos[e.from]?.[e.to] || 0;
                res[e.from][e.to] = (res[e.from][e.to]||0) + (e.capacity - f);
                res[e.to][e.from] = (res[e.to][e.from]||0) + f;
            });

            let padre = {};
            let resultadoBusqueda = bfs(fuente, sumidero, padre, res);
            if (resultadoBusqueda.encontrado) {
                pasos++;
                let curr = sumidero, cuello = Infinity, camino = [];
                while (curr !== fuente) {
                    let p = padre[curr];
                    cuello = Math.min(cuello, res[p][curr]);
                    camino.push([p, curr]);
                    curr = p;
                }
                camino.forEach(([u,v]) => {
                    if (grafo[u] && grafo[u][v] !== undefined) {
                        flujos[u][v] = (flujos[u][v] || 0) + cuello;
                    } else {
                        flujos[v][u] = (flujos[v][u] || 0) - cuello;
                    }
                });
                actualizarVista(camino.reverse());
                log(`Paso ${pasos}: Flujo de ${cuello} por [${camino.map(p => p.join('‚Üí')).join(', ')}]`, 'info');
            } else {
                terminado = true;
                finalizar(resultadoBusqueda.visitados);
            }
        }

        function ejecutarTodo() {
            let safety=0; while(!terminado && safety++ < 2 * N) pasoAlgoritmo();
        }

        function actualizarVista(camino) {
            edgesDS.forEach(e => {
                let f = flujos[e.from]?.[e.to] || 0;
                let esCaminoAdelante = camino.some(p => p[0] === e.from && p[1] === e.to);
                let esCaminoAtras = camino.some(p => p[0] === e.to && p[1] === e.from);
                let enCamino = esCaminoAdelante || esCaminoAtras;
                edgesDS.update({
                    id: e.id, label: `${f}/${e.capacity}`,
                    width: 1 + (f / e.capacity) * 3,
                    color: f === e.capacity ? '#e74c3c' : (enCamino ? '#f39c12' : '#95a5a6')
                });
            });
        }

        function finalizar(corteS) {
            let total = 0;
            for (let v in (flujos[fuente] || {})) total += flujos[fuente][v];
            log(`‚úÖ <strong>Flujo Maximo: ${total}</strong>`, 'success');
            corteS.forEach(u => { if (u !== fuente && u !== sumidero) nodesDS.update({ id: u, color: '#f1c40f' }); });
            aristasCorte = [];
            edgesDS.forEach(e => {
                if (corteS.has(e.from) && !corteS.has(e.to)) aristasCorte.push(e.id);
            });
            network.redraw();
            log(`‚ÑπÔ∏è Cortadura representada mediante una l√≠nea punteada rosada.`, 'info');
        }
    </script>
</body>
</html>



